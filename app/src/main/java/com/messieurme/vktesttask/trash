/*
package com.messieurme.vktesttask.ui.dashboard

import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import com.messieurme.vktesttask.MainViewModel
import com.messieurme.vktesttask.databinding.FragmentDashboardBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.*
import java.lang.StringBuilder
import java.net.URL
import javax.net.ssl.HttpsURLConnection

class DashboardFragment : Fragment() {

    private lateinit var mainViewModel: MainViewModel
    private lateinit var binding: FragmentDashboardBinding
    private var accessToken = ""
    //getC == chooseFile

    fun chooseFile() {
        var chooseFile: ActivityResultLauncher<String> =
            registerForActivityResult(ActivityResultContracts.GetContent()) { it: Uri ->
                println(it.path)
                println(it.encodedPath)
                var lol = 0
                var buff = ByteArray(1024)
                var iss = context?.contentResolver?.openInputStream(it)
                while (iss!!.read(buff).also { lol += it } != -1) {
                    continue
                }
            }
        chooseFile.launch("video/*")
    }


    var uploadFunction: (Uri, String, Int) -> Unit = { uri, uploadUrlString, offset  ->

        val uploaded = offset
        val fileSize = context?.contentResolver?.openFileDescriptor(uri, "r")!!.statSize
        val leftToUpload = fileSize - uploaded

        val dos: DataOutputStream?
        var bytesRead: Int

//        var sourceFile: File = File(
//            movies.listFiles()!!.filter { it.name.contains("video_1") }[0]!!.toURI()
//        )

        val url = URL(uploadUrlString)
        val fileInputStream = context?.contentResolver!!.openInputStream(uri)
        val connection: HttpsURLConnection =
            url.openConnection() as HttpsURLConnection
        connection.apply {
            doInput = true; // Allow Inputs
            doOutput = true; // Allow Outputs
            useCaches = false; // Don't use a Cached Copy
            requestMethod = "POST";
//                        connection.setRequestProperty("Connection", "Keep-Alive");
//                        connection.setRequestProperty("Cache-Control", "no-cache");
            setRequestProperty(
                "Content-Type",
                "application/octet-stream"
            )
            connection.setRequestProperty("Content-Length", "${leftToUpload}")
            connection.setRequestProperty("Session-ID", "228");
            connection.setRequestProperty(
                "Content-Disposition",
                "attachment; filename=\"video_1.mp4\""
            )
            connection.setRequestProperty(
                "Content-Range", "bytes $uploaded-${fileSize - 1}/$fileSize"
            )
        }
        dos = DataOutputStream(connection.outputStream);
        val buffer = ByteArray(1024 * 1024)
        var gT = 0
        println("SKIPPED: " + (fileInputStream.skip(uploaded.toLong()) == uploaded.toLong()).toString())
        while (fileInputStream.read(buffer).also { bytesRead = it } != -1) {
            dos.write(buffer, 0, bytesRead)
            gT += bytesRead
//                            println("READ: ${bytesRead}/$gT")
//                            if (gT == fir) break
        }
        println(gT)
        fileInputStream.close()
        dos.flush()
        dos.close()
        var resp = BufferedInputStream(connection.inputStream)
        var respRead = BufferedReader(InputStreamReader(resp))
        connection.headerFields.forEach { println(it) }
        var line = ""
        var sb = StringBuilder()
        while (respRead.readLine()?.also { line = it } != null) {
            sb.append(line).append("\n")
        }
        respRead.close()
        resp.close()
        connection.disconnect()
        println(sb.toString())
        println("END")
        var serverResponseCode = connection.responseCode
        println(serverResponseCode)

    }

    fun startUploading(uri: String) {
        if (binding.switchUploadMode.isChecked) {

        } else {

        }
    }


    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
//                askPermission()

        binding = FragmentDashboardBinding.inflate(inflater, container, false)
        mainViewModel = ViewModelProvider(requireActivity()).get(MainViewModel::class.java)
        mainViewModel.accessToken.observe(viewLifecycleOwner, {
            CoroutineScope(Dispatchers.Default).launch {
                if (it.isNotEmpty()) {
                    accessToken = it
                }
            }
        })
        return binding.root
    }


    fun askPermission() {
        val requestPermissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
                if (isGranted) {
                    println("COool")
                } else {
                }
            }
        when {
            ContextCompat.checkSelfPermission(
                requireContext(), android.Manifest.permission.READ_EXTERNAL_STORAGE
            ) == PackageManager.PERMISSION_GRANTED -> {

            }
            shouldShowRequestPermissionRationale("READ F...N STORAGE") -> {
                println("WHAT")
            }
            else -> {
                requestPermissionLauncher.launch(android.Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

    }


}
*/

/*
package com.messieurme.vktesttask.ui.home

import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.os.Environment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.MimeTypeMap
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.work.*
import com.google.gson.GsonBuilder
import com.messieurme.vktesttask.MainViewModel
import com.messieurme.vktesttask.R
import com.messieurme.vktesttask.databinding.FragmentHomeBinding
import com.messieurme.vktesttask.databinding.ItemUploadedBinding
import com.messieurme.vktesttask.retrofit.Get
import com.messieurme.vktesttask.retrofit.Video
import com.messieurme.vktesttask.service.UploadWorker
import com.squareup.picasso.Picasso
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.internal.notifyAll
import okhttp3.internal.wait
import okio.BufferedSink
import retrofit2.Retrofit
import retrofit2.awaitResponse
import retrofit2.converter.gson.GsonConverterFactory
import java.io.*
import java.lang.Exception
import java.lang.StringBuilder
import java.lang.Thread.sleep
import java.net.URL
import java.nio.file.Files
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import javax.net.ssl.HttpsURLConnection


class HomeFragment : Fragment() {

    private lateinit var homeViewModel: HomeViewModel
    private lateinit var mainViewModel: MainViewModel
    private lateinit var binding: FragmentHomeBinding

    private var threadForUpload: Thread = Thread()


    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        homeViewModel =
            ViewModelProvider(this).get(HomeViewModel::class.java)

        binding = FragmentHomeBinding.inflate(inflater, container, false)


        mainViewModel = ViewModelProvider(requireActivity()).get(MainViewModel::class.java)
        mainViewModel.accessToken.observe(viewLifecycleOwner, {
            if (it == null) return@observe
            CoroutineScope(Dispatchers.Default).launch {
                if (it.isNotEmpty()) {
                    //Id for uploaded is -1, but i'll download it
                    val uploadedId = getAlbumId(it)
                    val uplodedVideos = getVideosByAlbumId(it, uploadedId)

                    activity?.runOnUiThread {
                        binding.uploadedList.apply {
                            adapter = UploadedLisAdapter(uplodedVideos!!.response.items!!, context)
                            layoutManager =
                                LinearLayoutManager(context, RecyclerView.VERTICAL, false)
                        }
                    }


                    val movies =
                        requireContext().getExternalFilesDir(Environment.DIRECTORY_MOVIES)

                    var type: String? = null
                    val extension = MimeTypeMap.getFileExtensionFromUrl(
                        movies?.listFiles()!!.filter { it.name.contains("video_1") }[0].toUri()
                            .toString()
                    )
                    if (extension != null) {
                        type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension)
                    }
                    val pipeBody = PipeBody(type!!.toMediaType(), movies, lock, bool)
                    val hz = MultipartBody.Builder().setType(MultipartBody.FORM)
                        .addFormDataPart("video_file", "video_1.mp4", pipeBody)
                        .build()
                    val upl = Request.Builder()
                        .url("https://ovu.mycdn.me/upload.do?sig=48bee6b79f90740ace0022eac68c0f1bb6d8e78e&expires=1622709185059&clientType=14&appId=512000384397&id=2956905555998&userId=0&vkOwnerId=314830878&vkVideoId=456239469&vkVideoHash=6ca8474acf7aa2ceb6&vkUserId=314830878")
                        .post(hz)
                        .addHeader("Session-ID", "8388600")
                        .build()






                    threadForUpload = Thread {


                        var dos: DataOutputStream? = null;
                        var bytesRead = 0
                        var buffer = ByteArray(1024 * 1024);

                        var sourceFile: File = File(
                            movies.listFiles()!!.filter { it.name.contains("video_1") }[0]!!.toURI()
                        )

                        println(sourceFile.length())

                        val fileInputStream: FileInputStream = FileInputStream(sourceFile);
                        val url =
                            URL("https://ovu.mycdn.me/upload.do?sig=ed80301a3f369ffc88851424c6a9af32343efb48&expires=1622711573853&clientType=14&appId=512000384397&id=2957004187678&userId=0&vkOwnerId=314830878&vkVideoId=456239473&vkVideoHash=f9cb380ee257b4e946&vkUserId=314830878")
                        val connection: HttpsURLConnection =
                            url.openConnection() as HttpsURLConnection
                        val fir = 8388608
                        val total = 18206918
                        val tail = total - fir
                        connection.doInput = true; // Allow Inputs
                        connection.doOutput = true; // Allow Outputs
                        connection.useCaches = false; // Don't use a Cached Copy
                        connection.requestMethod = "POST";
//                        connection.setRequestProperty("Connection", "Keep-Alive");
//                        connection.setRequestProperty("Cache-Control", "no-cache");
                        connection.setRequestProperty(
                            "Content-Type",
                            "application/octet-stream"
                        )
                        connection.setRequestProperty("Content-Length", "${tail}")
                        connection.setRequestProperty("Session-ID", "228");
                        connection.setRequestProperty(
                            "Content-Disposition",
                            "attachment; filename=\"video_1.mp4\""
                        )
                        connection.setRequestProperty(
                            "Content-Range", "bytes $fir-${total - 1}/$total"
                        )

                        dos = DataOutputStream(connection.outputStream);
                        buffer = ByteArray(1024 * 1024)
                        var gT = 0
                        println("SKIPPED: " + (fileInputStream.skip(fir.toLong()) == fir.toLong()).toString())
                        while (fileInputStream.read(buffer).also { bytesRead = it } != -1) {
                            dos.write(buffer, 0, bytesRead)
                            gT += bytesRead
//                            println("READ: ${bytesRead}/$gT")
//                            if (gT == fir) break
                        }
                        println(gT)
                        fileInputStream.close()
                        dos.flush()
                        dos.close()
                        var resp = BufferedInputStream(connection.inputStream)
                        var respRead = BufferedReader(InputStreamReader(resp))
                        connection.headerFields.forEach { println(it) }
                        var line = ""
                        var sb = StringBuilder()
                        while (respRead.readLine()?.also { line = it } != null) {
                            sb.append(line).append("\n")
                        }
                        respRead.close()
                        resp.close()
                        connection.disconnect()
                        println(sb.toString())
                        println("END")
                        var serverResponseCode = connection.responseCode
                        println(serverResponseCode)


                        /*
                       //                        while (bytesRead > 0) {
                       //                            dos.write(buffer, 0, bytesRead)
                       //                            gT += bufferSize
                       //                            bytesRead = fileInputStream.read(buffer,)
                       //                            println("READ: ${bufferSize}/$gT")
                       //                        }
                          */


                        /*//                        var qwe = OkHttpClient().newCall(upl).enqueue(object : Callback {
    //                            override fun onFailure(call: Call, e: IOException) {
    //                                println("FAILURE")
    //                                println(e.message)
    //                                println(e.localizedMessage)
    //                                e.stackTrace.forEach { println(it) }
    //
    //                            }
    //
    //                            override fun onResponse(call: Call, response: Response) {
    //                                println("FUCKIN SUUCKSESS")
    //                            }
    //                        })
    //
    //                        var qwe = OkHttpClient().newCall(upl).execute()

    //                        val byteBuffer = ByteArray(2048)
    //                        val ios = FileInputStream(
    //                            movies.listFiles()!!.filter { it.name.contains("video_1") }[0]
    //                        )
    //                        var read = 0
    //                        var total = 0L


    //                        var all = ios.readBytes()

    //                        while (ios.read(byteBuffer).also { read = it } != -1) {
    //                            pipeBody.sink().write(byteBuffer, 0, read)
    //                            total += read.toLong()
    //                            println("OUT:" + total)
    //                        }
    //                        pipeBody.tot = total
    //                        var ii : Int = 600 * 1024 * 1024
    //                        pipeBody.tot = all.size.toLong()
    //                        pipeBody.all = all
    //                        println("END")
    //                        pipeBody.sink().close()*/
                    }

                    threadForUpload.start()
/*//                    var qwe = OkHttpClient().newCall(upl).enqueue(object : Callback {
//                        override fun onFailure(call: Call, e: IOException) {
//                            activity?.runOnUiThread {
//                                Toast.makeText(
//                                    requireContext(),
//                                    "------------FAILURE",
//                                    Toast.LENGTH_SHORT
//                                ).show()
//                            }
//                            println("FAILURE")
//                            println(e.message)
//                            println(e.localizedMessage)
//                            e.stackTrace.forEach { println(it) }
//                        }
//
//
//                        override fun onResponse(call: Call, response: Response) {
//                            println("FUCKIN SUUCKSESS")
//                            activity?.runOnUiThread {
//                                Toast.makeText(
//                                    requireContext(),
//                                    "SUCKSESS====================",
//                                    Toast.LENGTH_SHORT
//                                ).show()
//                            }
//
//                        }
//                    })
//                        var qwee = OkHttpClient().newCall(upl).execute()
*/








                    qwee = OkHttpClient()
                        .newBuilder()
                        .writeTimeout(100, TimeUnit.SECONDS)
                        .readTimeout(100, TimeUnit.SECONDS)
                        .build()
                    ann = qwee!!.newCall(upl)
//                    ann!!.execute()
//                    UploadWorker(requireContext())
//                        .execute()


                    var constr =
                        Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED)
                            .build()

                    var worki = OneTimeWorkRequest.Builder(UploadWorker::class.java)
                        .setConstraints(constr)
                        .addTag("Work")
                        .build()
                    //                    WorkManager
//                        .getInstance(requireContext())
//                        .enqueueUniqueWork("Work", ExistingWorkPolicy.KEEP, worki)



                }
            }
        })
        return binding.root
    }

    var ann: Call? = null

    var qwee: OkHttpClient? = null


    override fun onPause() {
        super.onPause()
        println("ONPAUTSE")
        bool.set(true)
    }

    var lock = ReentrantLock()
    var bool = AtomicBoolean(false)


    override fun onResume() {
        super.onResume()
        println("ONRESUME")
        bool.set(false)
        synchronized(bool) {
            bool.notifyAll()
        }
    }


    class PipeBody(
        private val mediaType: MediaType,
        private var movies: File,
        private var lock: ReentrantLock,
        private val bool: AtomicBoolean,
    ) : RequestBody() {

        override fun contentLength(): Long {
            return Files.size(
                movies.listFiles()!!.filter { it.name.contains("video_1") }[0].toPath()
            ) /*- 8388608*/
        }

        override fun contentType(): MediaType {
            return mediaType
        }

        override fun writeTo(sink: BufferedSink) {
            val byteBuffer = ByteArray(1024 * 1024)
            val ios = FileInputStream(
                movies.listFiles()!!.filter { it.name.contains("video_1") }[0]
            )
            var read = 0
            var total = 0L

            var all = Files.size(
                movies.listFiles()!!.filter { it.name.contains("video_1") }[0].toPath()
            )
            println(all)
//            ios.skip(8388608)
            synchronized(bool) {
                try {
                    println(ios.skip(8388608L))
                    while (ios.read(byteBuffer).also { read = it } != -1) {
                        if (bool.get()) bool.wait()
                        sink.outputStream().write(byteBuffer, 0, read)
                        total += read.toLong()
                        println("Progress:" + (total.toFloat() / all.toFloat()) + "::$total/$all")
//                        if (total.toFloat() / all.toFloat() > 0.4) sleep(45_000)
//                        if (total == 8388608L) break
//                        var s = System.currentTimeMillis()
                    }
                } catch (e: Exception) {
//                    var type: String? = null
//                    val extension = MimeTypeMap.getFileExtensionFromUrl(
//                        movies?.listFiles()!!.filter { it.name.contains("video_1") }[0].toUri()
//                            .toString()
//                    )
//                    if (extension != null) {
//                        type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension)
//                    }
//                    var pipeBody: PipeBody = PipeBody(
//                        type!!.toMediaType(),
//                        movies, lock, bool
//                    )

//                    var pb = object : RequestBody() {
//                        override fun contentType(): MediaType? {
//                            return mediaType
//                        }
//
//                        override fun writeTo(sink: BufferedSink) {
//                            sink.outputStream().write(byteBuffer, 0, read)
//                            total += read.toLong()
//                            while (ios.read(byteBuffer).also { read = it } != -1) {
//                                sink.outputStream().write(byteBuffer, 0, read)
//                                total += read.toLong()
//                                println("Rrogress:" + (total.toFloat() / all.toFloat()) + "::$total/$all")
//                            }
//                        }
//
//                        override fun contentLength(): Long {
//                            return total - read
//                        }
//                    }
//
//                    var hz = MultipartBody.Builder().setType(MultipartBody.FORM)
//                        .addFormDataPart("video_file", "video_1.mp4", pb)
//                        .build()
//
//                    println("bytes $total-${all}/${all}")
//                    val upl = Request.Builder()
//                        .url("https://ovu.mycdn.me/upload.do?sig=5b22ad4b18550cd8aad3cf2732a27c19255157f9&expires=1622676360510&clientType=14&appId=512000384397&id=2955871266846&userId=0&vkOwnerId=314830878&vkVideoId=456239453&vkVideoHash=5b7b867062b24a1e57&vkUserId=314830878")
//                        .addHeader("Content-Range", "bytes $total-${all}/${all}")
//                        .post(hz)
//                        .build()
//                    val client = OkHttpClient()
//                        .newBuilder()
//                        .writeTimeout(100, TimeUnit.SECONDS)
//                        .readTimeout(100, TimeUnit.SECONDS)
//                        .build()
//                    client.newCall(upl).execute()
//
                }
//                }
            }
            ios.close()
        }
    }


    class UploadedLisAdapter(
        private val titles: List<Get.Response.Items>,
        private val context: Context
    ) :
        RecyclerView.Adapter<UploadedLisAdapter.CustomViewHolder>() {

        inner class CustomViewHolder(item: ItemUploadedBinding) :
            RecyclerView.ViewHolder(item.root) {
            private var binding: ItemUploadedBinding = item

            fun bind(info: Get.Response.Items, context: Context) {
                binding.textView.text = info.title

                Picasso
                    .with(context)
                    .load(Uri.parse(info.image?.random()?.url))
                    .fit().centerCrop()
                    .placeholder(R.drawable.ic_launcher_foreground)
                    .into(binding.imageView)
            }
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = CustomViewHolder(
            ItemUploadedBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )


        override fun onBindViewHolder(holder: CustomViewHolder, position: Int) {
            holder.bind(titles[position], context)
        }

        override fun getItemCount() = titles.size


    }

    private suspend fun getVideosByAlbumId(accessToken: String, uploadedId: Int?): Get? {
        val response = retrofit.get(uploadedId!!, accessToken, "5.131").awaitResponse()
        return response.body()
    }

    var retrofit = Retrofit.Builder()
        .baseUrl("https://api.vk.com/method/")
        .addConverterFactory(
            GsonConverterFactory.create(
                GsonBuilder().setLenient().create()
            )
        )
        .build().create(Video::class.java)

    private suspend fun getAlbumId(accessToken: String): Int? {
        val response = retrofit.getAlbums(accessToken, 1, "5.131").awaitResponse()
        return response.body()?.response?.items?.find { it.title == "Загруженные" }?.id
    }
}

*/
/*
package com.messieurme.vktesttask.ui.dashboard

import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import com.messieurme.vktesttask.MainViewModel
import com.messieurme.vktesttask.databinding.FragmentDashboardBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.io.*
import java.lang.StringBuilder
import java.net.URL
import javax.net.ssl.HttpsURLConnection
import kotlin.math.min

class DashboardFragment : Fragment() {

    private lateinit var mainViewModel: MainViewModel
    private lateinit var binding: FragmentDashboardBinding
    private var accessToken = ""
    //getC == chooseFile

    fun chooseFile() {
        var chooseFile: ActivityResultLauncher<String> =
            registerForActivityResult(ActivityResultContracts.GetContent()) { it: Uri ->
                println(it.path)
                println(it.encodedPath)
                var lol = 0
                var buff = ByteArray(1024)
                var iss = context?.contentResolver?.openInputStream(it)
                while (iss!!.read(buff).also { lol += it } != -1) {
                    continue
                }
            }
        chooseFile.launch("video/*")
    }

    private fun getHttpsUrlConnection(
        url: URL,
        uploaded: Long,
        fileSize: Long,
        batchSize: Long,
        sessionID: Int
    ) =
        (url.openConnection() as HttpsURLConnection).apply {
            doInput = true
            doOutput = true
            useCaches = false
            requestMethod = "POST";
            setRequestProperty("Session-ID", "$sessionID")
            setRequestProperty("Content-Length", "$batchSize")
            setRequestProperty(
                "Content-Disposition",
                "attachment; filename=\"another_video$sessionID.mp4\""
            )
            setRequestProperty("Content-Type", "application/octet-stream")
            setRequestProperty(
                "Content-Range",
                "bytes $uploaded-${min(uploaded + batchSize, fileSize - uploaded)}/$fileSize"
            )
        }


    //5MB
    var BATCH_SIZE = 5 * 1024L * 1024L

    var uploadFunction: (Uri, String, Long, InputStream) -> Int =
        { uri, uploadUrlString, offset, inputStr: InputStream ->
            val uploaded = offset
            val fileSize = context?.contentResolver?.openFileDescriptor(uri, "r")!!.statSize
            val leftToUpload = fileSize - uploaded

            val url = URL(uploadUrlString)
            val connection: HttpsURLConnection =
                getHttpsUrlConnection(url, uploaded, fileSize, BATCH_SIZE)


            //TODO(Open input stream each time bad practice. Better open once and then reuse it)
            inputStr.use { fileInputStream ->
                if (uploaded != 0L && fileInputStream.skip(uploaded) != uploaded) {
                    //TODO(Error. Skipped number incorrect. Throw Exception)
                }

                DataOutputStream(connection.outputStream).use { dataOuputStream ->
                    var bytesRead: Int
                    var progress = uploaded
                    val buffer = ByteArray(1024 * 1024)
                    while (fileInputStream.read(buffer).also { bytesRead = it } != -1) {
                        dataOuputStream.write(buffer, 0, bytesRead)
                        progress += bytesRead
                        //TODO(Enable stopping somehow)
                    }
                    dataOuputStream.flush()
                }
            }
            connection.disconnect()

            connection.responseCode
        }

    fun startUploading(uri: String) {
        if (binding.switchUploadMode.isChecked) {

        } else {

        }
    }


    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
//        TODO(Permission?)
//                askPermission()

        binding = FragmentDashboardBinding.inflate(inflater, container, false)
        mainViewModel = ViewModelProvider(requireActivity()).get(MainViewModel::class.java)
        mainViewModel.accessToken.observe(viewLifecycleOwner, {
            CoroutineScope(Dispatchers.Default).launch {
                if (it.isNotEmpty()) {
                    accessToken = it
                }
            }
        })
        return binding.root
    }


    fun askPermission() {
        val requestPermissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
//                TODO("Permissions")
                if (isGranted) {
                    println("COool")
                } else {
                }
            }
        when {
            ContextCompat.checkSelfPermission(
                requireContext(), android.Manifest.permission.READ_EXTERNAL_STORAGE
            ) == PackageManager.PERMISSION_GRANTED -> {

            }
            shouldShowRequestPermissionRationale("READ F...N STORAGE") -> {
                println("WHAT")
            }
            else -> {
                requestPermissionLauncher.launch(android.Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

    }


}
*/